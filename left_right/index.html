<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A concurrency primitive for high concurrency reads over a single-writer data structure."><meta name="keywords" content="rust, rustlang, rust-lang, left_right"><title>left_right - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../ayu.css" disabled ><script id="default-settings"></script><script src="../storage.js"></script><script src="../crates.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="icon" type="image/svg+xml" href="../favicon.svg">
<link rel="alternate icon" type="image/png" href="../favicon-16x16.png">
<link rel="alternate icon" type="image/png" href="../favicon-32x32.png"><style type="text/css">#crate-search{background-image:url("../down-arrow.svg");}</style></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu" role="button">&#9776;</div><a href='../left_right/index.html'><div class='logo-container rust-logo'><img src='../rust-logo.png' alt='logo'></div></a><p class="location">Crate left_right</p><div class="block version"><p>Version 0.11.4</p></div><div class="sidebar-elems"><a id="all-types" href="all.html"><p>See all left_right's items</p></a><div class="block items"><ul><li><a href="#modules">Modules</a></li><li><a href="#structs">Structs</a></li><li><a href="#traits">Traits</a></li><li><a href="#functions">Functions</a></li></ul></div><p class="location"></p><div id="sidebar-vars" data-name="left_right" data-ty="mod" data-relpath="../"></div><script defer src="../sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu"><img src="../brush.svg" width="18" height="18" alt="Pick another theme!"></button><div id="theme-choices" role="menu"></div></div><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" class="help-button">?</button>
                <a id="settings-menu" href="../settings.html"><img src="../wheel.svg" width="18" height="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class="fqn"><span class="in-band">Crate <a class="mod" href="">left_right</a><button id="copy-path" onclick="copy_path(this)">⎘</button></span><span class="out-of-band"><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span><a class="srclink" href="../src/left_right/lib.rs.html#1-299" title="goto source code">[src]</a></span></h1><div class="docblock"><p>A concurrency primitive for high concurrency reads over a single-writer data structure.</p>
<p>The primitive keeps two copies of the backing data structure, one that is accessed by readers,
and one that is access by the (single) writer. This enables all reads to proceed in parallel
with minimal coordination, and shifts the coordination overhead to the writer. In the absence
of writes, reads scale linearly with the number of cores.</p>
<p>When the writer wishes to expose new changes to the datastructure (see
<a href="struct.WriteHandle.html#method.publish" title="WriteHandle::publish"><code>WriteHandle::publish</code></a>), it “flips” the two copies so that subsequent reads go to the old
“write side”, and future writers go to the old “read side”. This process does cause two cache
line invalidations for the readers, but does not stop them from making progress (i.e., reads
are wait-free).</p>
<p>In order to keep both copies up to date, left-right keeps an operational log (“oplog”) of all
the modifications to the data structure, which it uses to bring the old read data up to date
with the latest writes on a flip. Since there are two copies of the data, each oplog entry is
applied twice: once to the write copy and again to the (stale) read copy.</p>
<h1 id="trade-offs" class="section-header"><a href="#trade-offs">Trade-offs</a></h1>
<p>Few concurrency wins come for free, and this one is no exception. The drawbacks of this
primitive are:</p>
<ul>
<li><strong>Increased memory use</strong>: since we keep two copies of the backing data structure, we are
effectively doubling the memory use of the underlying data. With some clever de-duplication,
this cost can be ameliorated to some degree, but it’s something to be aware of. Furthermore,
if writers only call <code>publish</code> infrequently despite adding many writes to the operational log,
the operational log itself may grow quite large, which adds additional overhead.</li>
<li><strong>Deterministic operations</strong>: as the entries in the operational log are applied twice, once
to each copy of the data, it is essential that the operations are deterministic. If they are
not, the two copies will no longer mirror one another, and will continue to diverge over time.</li>
<li><strong>Single writer</strong>: left-right only supports a single writer. To have multiple writers, you
need to ensure exclusive access to the <a href="struct.WriteHandle.html" title="WriteHandle"><code>WriteHandle</code></a> through something like a
<a href="https://doc.rust-lang.org/nightly/std/sync/mutex/struct.Mutex.html"><code>Mutex</code></a>.</li>
<li><strong>Slow writes</strong>: Writes through left-right are slower than they would be directly against
the backing datastructure. This is both because they have to go through the operational log,
and because they must each be applied twice.</li>
</ul>
<h1 id="how-does-it-work" class="section-header"><a href="#how-does-it-work">How does it work?</a></h1>
<p>Take a look at <a href="https://www.youtube.com/watch?v=eLNAMEoKAAc">this YouTube video</a> which goes
through the basic concurrency algorithm, as well as the initial development of this library.
Alternatively, there’s a shorter (but also less complete) description in <a href="https://www.youtube.com/watch?v=s19G6n0UjsM&amp;t=1994">this
talk</a>.</p>
<p>At a glance, left-right is implemented using two regular <code>T</code>s, an operational log, epoch
counting, and some pointer magic. There is a single pointer through which all readers go. It
points to a <code>T</code> that the readers access in order to read data. Every time a read has accessed
the pointer, they increment a local epoch counter, and they update it again when they have
finished the read. When a write occurs, the writer updates the other <code>T</code> (for which there are
no readers), and also stores a copy of the change in a log. When <a href="struct.WriteHandle.html#method.publish" title="WriteHandle::publish"><code>WriteHandle::publish</code></a> is
called, the writer, atomically swaps the reader pointer to point to the other <code>T</code>. It then
waits for the epochs of all current readers to change, and then replays the operational log to
bring the stale copy up to date.</p>
<p>The design resembles this <a href="https://hal.archives-ouvertes.fr/hal-01207881/document">left-right concurrency
scheme</a> from 2015, though I am not
aware of any follow-up to that work.</p>
<h1 id="how-do-i-use-it" class="section-header"><a href="#how-do-i-use-it">How do I use it?</a></h1>
<p>If you just want a data structure for fast reads, you likely want to use a crate that <em>uses</em>
this crate, like <a href="https://docs.rs/evmap/"><code>evmap</code></a>. If you want to develop such a crate
yourself, here’s what you do:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">left_right</span>::{<span class="ident">Absorb</span>, <span class="ident">ReadHandle</span>, <span class="ident">WriteHandle</span>};

<span class="comment">// First, define an operational log type.</span>
<span class="comment">// For most real-world use-cases, this will be an `enum`, but we&#39;ll keep it simple:</span>
<span class="kw">struct</span> <span class="ident">CounterAddOp</span>(<span class="ident">i32</span>);

<span class="comment">// Then, implement the unsafe `Absorb` trait for your data structure type,</span>
<span class="comment">// and provide the oplog type as the generic argument.</span>
<span class="comment">// You can read this as &quot;`i32` can absorb changes of type `CounterAddOp`&quot;.</span>
<span class="kw">impl</span> <span class="ident">Absorb</span><span class="op">&lt;</span><span class="ident">CounterAddOp</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="ident">i32</span> {
    <span class="comment">// See the documentation of `Absorb::absorb_first`.</span>
    <span class="comment">//</span>
    <span class="comment">// Essentially, this is where you define what applying</span>
    <span class="comment">// the oplog type to the datastructure does.</span>
    <span class="kw">fn</span> <span class="ident">absorb_first</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>, <span class="ident">operation</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">CounterAddOp</span>, <span class="kw">_</span>: <span class="kw-2">&amp;</span><span class="self">Self</span>) {
        <span class="kw-2">*</span><span class="self">self</span> <span class="op">+</span><span class="op">=</span> <span class="ident">operation</span>.<span class="number">0</span>;
    }

    <span class="comment">// See the documentation of `Absorb::absorb_second`.</span>
    <span class="comment">//</span>
    <span class="comment">// This may or may not be the same as `absorb_first`,</span>
    <span class="comment">// depending on whether or not you de-duplicate values</span>
    <span class="comment">// across the two copies of your data structure.</span>
    <span class="kw">fn</span> <span class="ident">absorb_second</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>, <span class="ident">operation</span>: <span class="ident">CounterAddOp</span>, <span class="kw">_</span>: <span class="kw-2">&amp;</span><span class="self">Self</span>) {
        <span class="kw-2">*</span><span class="self">self</span> <span class="op">+</span><span class="op">=</span> <span class="ident">operation</span>.<span class="number">0</span>;
    }

    <span class="comment">// See the documentation of `Absorb::drop_first`.</span>
    <span class="kw">fn</span> <span class="ident">drop_first</span>(<span class="self">self</span>: <span class="ident">Box</span><span class="op">&lt;</span><span class="self">Self</span><span class="op">&gt;</span>) {}

    <span class="kw">fn</span> <span class="ident">sync_with</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>, <span class="ident">first</span>: <span class="kw-2">&amp;</span><span class="self">Self</span>) {
        <span class="kw-2">*</span><span class="self">self</span> <span class="op">=</span> <span class="kw-2">*</span><span class="ident">first</span>
    }
}

<span class="comment">// Now, you can construct a new left-right over an instance of your data structure.</span>
<span class="comment">// This will give you a `WriteHandle` that accepts writes in the form of oplog entries,</span>
<span class="comment">// and a (cloneable) `ReadHandle` that gives you `&amp;` access to the data structure.</span>
<span class="kw">let</span> (<span class="ident">write</span>, <span class="ident">read</span>) <span class="op">=</span> <span class="ident">left_right::new</span>::<span class="op">&lt;</span><span class="ident">i32</span>, <span class="ident">CounterAddOp</span><span class="op">&gt;</span>();

<span class="comment">// You will likely want to embed these handles in your own types so that you can</span>
<span class="comment">// provide more ergonomic methods for performing operations on your type.</span>
<span class="kw">struct</span> <span class="ident">Counter</span>(<span class="ident">WriteHandle</span><span class="op">&lt;</span><span class="ident">i32</span>, <span class="ident">CounterAddOp</span><span class="op">&gt;</span>);
<span class="kw">impl</span> <span class="ident">Counter</span> {
    <span class="comment">// The methods on you write handle type will likely all just add to the operational log.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">add</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>, <span class="ident">i</span>: <span class="ident">i32</span>) {
        <span class="self">self</span>.<span class="number">0</span>.<span class="ident">append</span>(<span class="ident">CounterAddOp</span>(<span class="ident">i</span>));
    }

    <span class="comment">// You should also provide a method for exposing the results of any pending operations.</span>
    <span class="comment">//</span>
    <span class="comment">// Until this is called, any writes made since the last call to `publish` will not be</span>
    <span class="comment">// visible to readers. See `WriteHandle::publish` for more details. Make sure to call</span>
    <span class="comment">// this out in _your_ documentation as well, so that your users will be aware of this</span>
    <span class="comment">// &quot;weird&quot; behavior.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">publish</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>) {
        <span class="self">self</span>.<span class="number">0</span>.<span class="ident">publish</span>();
    }
}

<span class="comment">// Similarly, for reads:</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Clone</span>)]</span>
<span class="kw">struct</span> <span class="ident">CountReader</span>(<span class="ident">ReadHandle</span><span class="op">&lt;</span><span class="ident">i32</span><span class="op">&gt;</span>);
<span class="kw">impl</span> <span class="ident">CountReader</span> {
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">get</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">i32</span> {
        <span class="comment">// The `ReadHandle` itself does not allow you to access the underlying data.</span>
        <span class="comment">// Instead, you must first &quot;enter&quot; the data structure. This is similar to</span>
        <span class="comment">// taking a `Mutex`, except that no lock is actually taken. When you enter,</span>
        <span class="comment">// you are given back a guard, which gives you shared access (through the</span>
        <span class="comment">// `Deref` trait) to the &quot;read copy&quot; of the data structure.</span>
        <span class="comment">//</span>
        <span class="comment">// Note that `enter` may yield `None`, which implies that the `WriteHandle`</span>
        <span class="comment">// was dropped, and took the backing data down with it.</span>
        <span class="comment">//</span>
        <span class="comment">// Note also that for as long as the guard lives, a writer that tries to</span>
        <span class="comment">// call `WriteHandle::publish` will be blocked from making progress.</span>
        <span class="self">self</span>.<span class="number">0</span>.<span class="ident">enter</span>().<span class="ident">map</span>(<span class="op">|</span><span class="ident">guard</span><span class="op">|</span> <span class="kw-2">*</span><span class="ident">guard</span>).<span class="ident">unwrap_or</span>(<span class="number">0</span>)
    }
}

<span class="comment">// These wrapper types are likely what you&#39;ll give out to your consumers.</span>
<span class="kw">let</span> (<span class="kw-2">mut</span> <span class="ident">w</span>, <span class="ident">r</span>) <span class="op">=</span> (<span class="ident">Counter</span>(<span class="ident">write</span>), <span class="ident">CountReader</span>(<span class="ident">read</span>));

<span class="comment">// They can then use the type fairly ergonomically:</span>
<span class="macro">assert_eq!</span>(<span class="ident">r</span>.<span class="ident">get</span>(), <span class="number">0</span>);
<span class="ident">w</span>.<span class="ident">add</span>(<span class="number">1</span>);
<span class="comment">// no call to publish, so read side remains the same:</span>
<span class="macro">assert_eq!</span>(<span class="ident">r</span>.<span class="ident">get</span>(), <span class="number">0</span>);
<span class="ident">w</span>.<span class="ident">publish</span>();
<span class="macro">assert_eq!</span>(<span class="ident">r</span>.<span class="ident">get</span>(), <span class="number">1</span>);
<span class="ident">drop</span>(<span class="ident">w</span>);
<span class="comment">// writer dropped data, so reads yield fallback value:</span>
<span class="macro">assert_eq!</span>(<span class="ident">r</span>.<span class="ident">get</span>(), <span class="number">0</span>);</pre></div>
<p>One additional noteworthy detail: much like with <code>Mutex</code>, <code>RwLock</code>, and <code>RefCell</code> from the
standard library, the values you dereference out of a <code>ReadGuard</code> are tied to the lifetime of
that <code>ReadGuard</code>. This can make it awkward to write ergonomic methods on the read handle that
return references into the underlying data, and may tempt you to clone the data out or take a
closure instead. Instead, consider using <a href="struct.ReadGuard.html#method.map" title="ReadGuard::map"><code>ReadGuard::map</code></a> and <a href="struct.ReadGuard.html#method.try_map" title="ReadGuard::try_map"><code>ReadGuard::try_map</code></a>, which
(like <code>RefCell</code>’s <a href="https://doc.rust-lang.org/nightly/core/cell/struct.Ref.html#method.map"><code>Ref::map</code></a>) allow you to provide a guarded reference
deeper into your data structure.</p>
</div><h2 id="modules" class="section-header"><a href="#modules">Modules</a></h2>
<table><tr class="module-item"><td><a class="mod" href="aliasing/index.html" title="left_right::aliasing mod">aliasing</a></td><td class="docblock-short"><p>Types that aid in aliasing values across the two left-right data copies.</p>
</td></tr></table><h2 id="structs" class="section-header"><a href="#structs">Structs</a></h2>
<table><tr class="module-item"><td><a class="struct" href="struct.ReadGuard.html" title="left_right::ReadGuard struct">ReadGuard</a></td><td class="docblock-short"><p>A guard wrapping a live reference into a left-right protected <code>T</code>.</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.ReadHandle.html" title="left_right::ReadHandle struct">ReadHandle</a></td><td class="docblock-short"><p>A read handle to a left-right guarded data structure.</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.ReadHandleFactory.html" title="left_right::ReadHandleFactory struct">ReadHandleFactory</a></td><td class="docblock-short"><p>A type that is both <code>Sync</code> and <code>Send</code> and lets you produce new <a href="struct.ReadHandle.html" title="ReadHandle"><code>ReadHandle</code></a> instances.</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.Taken.html" title="left_right::Taken struct">Taken</a></td><td class="docblock-short"><p>A <strong>smart pointer</strong> to an owned backing data structure. This makes sure that the
data is dropped correctly (using <a href="trait.Absorb.html#method.drop_second" title="Absorb::drop_second"><code>Absorb::drop_second</code></a>).</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.WriteHandle.html" title="left_right::WriteHandle struct">WriteHandle</a></td><td class="docblock-short"><p>A writer handle to a left-right guarded data structure.</p>
</td></tr></table><h2 id="traits" class="section-header"><a href="#traits">Traits</a></h2>
<table><tr class="module-item"><td><a class="trait" href="trait.Absorb.html" title="left_right::Absorb trait">Absorb</a></td><td class="docblock-short"><p>Types that can incorporate operations of type <code>O</code>.</p>
</td></tr></table><h2 id="functions" class="section-header"><a href="#functions">Functions</a></h2>
<table><tr class="module-item"><td><a class="fn" href="fn.new.html" title="left_right::new fn">new</a></td><td class="docblock-short"><p>Construct a new write and read handle pair from the data structure default.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.new_from_empty.html" title="left_right::new_from_empty fn">new_from_empty</a></td><td class="docblock-short"><p>Construct a new write and read handle pair from an empty data structure.</p>
</td></tr></table></section><section id="search" class="content hidden"></section><div id="rustdoc-vars" data-root-path="../" data-current-crate="left_right" data-search-index-js="../search-index.js" data-search-js="../search.js"></div>
    <script src="../main.js"></script></body></html>